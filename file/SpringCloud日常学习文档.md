### 7月2、3号 

1. 搭建Eureka注册中心
   - 注册微服务  --在注册中心注册
   - 注册两个微服务，便得到两个实例
   
2. ribbon负载均衡
   - Ribbon 是使用 restTemplate 工具进行调用，并进行客户端负载均衡
   - 客户端负载均衡
     - 注册中心注册了端口为8001和8002两个数据微服务， Ribbon 会从注册中心获知这个信息，然后由 Ribbon 这个客户端通过注册中心自己决定调用哪一个数据微服务
   
3. Feign

   -  Feign 是对 Ribbon的封装，使用注解的方式，调用起来更简单, 也是主流的方式
   

   

   
例会：
   
   ---
   
   

### 7.6周一

1. 服务链路追踪

   - zipkin 服务链路追踪服务器
   - 在前面的例子里，我们有两个微服务，分别是数据服务和视图服务，随着业务的增加，就会有越来越多的微服务存在，他们之间也会有更加复杂的调用关系。
     这个调用关系，仅仅通过观察代码，会越来越难以识别，所以就需要通过 zipkin 服务链路追踪服务器 这个东西来用图片进行识别了。

2. 配置服务器

   - 有时候，微服务要做集群，这就意味着，会有多个微服务实例。 在业务上有时候需要修改一些配置信息，比如说 版本信息吧~ 倘若没有配置服务， 那么就需要挨个修改微服务，挨个重新部署微服务，这样就比较麻烦。
     为了偷懒， 这些配置信息就会放在一个公共的地方，比如git, 然后通过配置服务器把它获取下来，然后微服务再从配置服务器上取下来。
     这样只要修改git上的信息，那么同一个集群里的所有微服务都立即获取相应信息了，这样就大大节约了开发，上线和重新部署的时间了。

     如图所示，我们先在 git 里保存 version 信息， 然后通过 ConfigServer 去获取 version 信息， 接着不同的视图微服务实例再去 ConfigServer 里获取 version.

3. 配置服务端

   - 把现成的 **视图微服务-Feign**改造成配置客户端，使得其可以从配置服务器上获取版本信息

4.  rabbitMQ 动态刷新

   - 之前的教程虽然配置了config-server, 也把 视图服务改造成了配置客户端，但是当需要刷新配置信息的时候，不得不既重启 config-server, 又重启微服务。 这样的体验当然是不太好的。 我们当然是希望一旦 git 上的配置信息修改之后，就可以自动地刷新到微服务里，而不是需要手动重启才可以。

     本知识点就是为了解决这个问题的。

   - springCloud 通过 rabbitMQ 来进行消息广播，以达到有配置信息发生改变的时候，广播给多个微服务的效果。

   - 所以需要先安装 rabbitMQ 服务器。
     站长已经准备好了 rabbitMQ 服务器的教程：
     [rabbitMQ 教程](https://how2j.cn/k/message/message-rabbitmq/2029.html)，里面包括安装和简单的使用。 不熟悉的同学请前往预习，不然后面的效果做不出来滴

   - 消息中间件rabbitMQ

     -  Rabbit 拿到消息之后，会先交给 交换机 （Exchange）, 然后交换机再根据预先设定的不同绑定( Bindings )策略，来确定要发给哪个队列。
     - RabbitMQ提供了四种Exchange模式：fanout,direct,topic,header 。 header模式在实际使用中较少，这里只讨论前三种模式.
       - fanout 模式就是广播模式~
         消息来了，会发给所有的队列~
       - Direct 模式就是指定队列模式， 消息来了，只发给指定的 Queue, 其他Queue 都收不到。
       - Topic 模式主题模式是什么意思呢？ 如图所示消息来源有： 美国新闻，美国天气，欧洲新闻，欧洲天气。
         如果你想看 **美国**主题： 那么就会收到 **美国**新闻，**美国**天气。
         如果你想看 **新闻**主题： 那么就会收到 美国**新闻**，欧洲**新闻**。
         如果你想看 **天气**主题： 那么就会收到 美国**天气**，欧洲**天气**。
         如果你想看 **欧洲**主题： 那么就会收到 **欧洲**新闻，**欧洲**天气。
     - 客户端引入了rmq的依赖，rmq就是消息总线，当我们调用/actuator/refresh接口时，其实就是向消息总线发送了一个更新配置的请求消息，然后消息总线再将此消息广播给所有使用此配置的微服务，微服务再重新去服务端拉取配置。rmq起作用都是自动的，我们没有去参与。

5. 断路器：

   - 所谓的断路器，就是当被访问的微服务无法使用的时候，当前服务能够感知这个现象，并且提供一个备用的方案出来。
     比如：数据微服务无法使用了，如果有了断路器，那么视图微服务就能够知道此事，并且展示给用户相关的信息。 而不会报错或者一直卡在那里~
   - 断路器监控
     - 前面讲解了断路器， 当数据服务不可用的时候， 断路器就会发挥作用。
       那么数据服务什么时候可用，什么时候不可用，如何监控这个事情呢？ 我们就要用到 断路器监控 来可视化掌控这个情况了

   - 断路器监控聚合
     - 在上个知识点讲解了**针对一个微服务**的断路器监控，但是微服务通常会是多个实例组成的一个集群。 倘若集群里的实例比较多，难道要挨个挨个去监控这些实例吗？ 何况有时候，根据集群的需要，会动态增加或者减少实例，监控起来就更麻烦了。
       所以为了方便监控集群里的多个实例，springCloud 提供了一个 turbine 项目，它的作用是把一个集群里的多个实例汇聚在一个 turbine里，这个然后再在 断路器监控里查看这个 turbine, 这样就能够在集群层面进行监控啦。

6. 网关

   - 我们现在有两种微服务，分别是数据微服务和视图微服务。
     他们有可能放在不同的 ip 地址上，有可能是不同的端口。
     为了访问他们，就需要记录这些地址和端口。 而地址和端口都可能会变化，这就增加了访问者的负担。
     所以这个时候，我们就可以用网关来解决这个问题。
     如图所示，我们只需要记住网关的地址和端口号就行了。
     如果要访问数据服务，访问地址 http://ip:port/api-data/products 即可。
     如果要访问视图服务，访问地址 http://ip:port/api-view/products 即可。
   - 什么时候用：可能是视图微服务也需要多个集群的，比如数据渲染到页面上（thymeleaf）也需要时间的，zuul提供一个统一的入口，并负载均衡转发到任意一个视图微服务上。或者我仅仅是想访问数据微服务，那么要有个统一入口，这个时候就必须要用网关了。

7. 端口总结

   - 用到的端口：

   - 服务注册中心：Eureka:8761

   - 数据微服务：product-data-service:8001~8003
   - 视图微服务：product-view-service-ribbon:8010
   - 视图微服务：product-viet-service-feign:8012~8014
   - 断路器：hystrix-dashboard:8020
   - 断路器监控聚合：turbine:8021
   - 配置服务：config-server:8030
   - 网关：zuul:8040
   - 第三方：
   - 服务链路追踪：zipkin ：9411
   - rabbitMQ:5672

